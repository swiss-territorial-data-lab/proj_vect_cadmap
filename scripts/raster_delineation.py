import os
import cv2
import argparse
import numpy as np
from tqdm import tqdm
from kneed import KneeLocator
from skimage import morphology

import os.path as osp
import networkx as nx
from kneed import KneeLocator
from skimage import morphology
from skimage.color import rgb2gray
from skimage.filters import gaussian
from skimage.segmentation import active_contour

def parse_args():
    parser = argparse.ArgumentParser(description='Delineate the raster mask generated by the deep learning models.')
    parser.add_argument('--tif_path',
                        default="./data/Carouge/",
                        help='the dir to load initial GeoTOFF file.')
    parser.add_argument('--line_mask',
                        default="./data/line_prediction_mask/",
                        help='the dir to load line prediction masks.')
    parser.add_argument('--save_path',
                        default="./data/delineation/",
                        help='the dir to save delineated results.')

    args = parser.parse_args()

    return args


def calculate_thred(image_gray, bg_conn=8):  
    # Adaptive threshold calculation 
    # Calculate the distribution of the cca
    image_rev = cv2.bitwise_not(image_gray)
    _, _, stats_0, _ = cv2.connectedComponentsWithStats(image_rev, connectivity=bg_conn, ltype=cv2.CV_32S)

    _, _, stats_1, _ = cv2.connectedComponentsWithStats(image_gray, connectivity=8, ltype=cv2.CV_32S)

    stats = np.concatenate((stats_0, stats_1), axis=0)
    indices = np.where((stats[:,0] == 0) & (stats[:,1] == 0)) [0]
    # Delete the background
    stats = np.delete(stats, indices, axis=0)

    # Calculate the distribution of the list
    count, nbr_pixels = np.histogram(np.log2(stats[:,4]), bins=1000)
    hist = np.array([[c,n] for c, n in zip(count[1:], nbr_pixels) if c!=0])

    smoothed_hist = [hist[-1].copy()]

    for y, x in hist[::-1]:
        if y >= smoothed_hist[-1][0]:
            smoothed_hist.append([y, x])

    smoothed_hist = np.array(smoothed_hist)

    poly_cof = np.polyfit(smoothed_hist[:, 1], smoothed_hist[:, 0], 4)
    poly_func = np.poly1d(poly_cof)

    # Use the Kneedle algorithm to detect the elbow of the curve
    order_max = int(np.ceil(np.log2(max(stats[:,4]))))
    x = range(order_max)
    kneedle = KneeLocator(x, poly_func(x), S=1, curve='convex', direction='decreasing', interp_method="interp1d")

    threshold = 2**(kneedle.knee)
    print('Threshold for cleaning small area: {}'.format(threshold))
    
    return threshold

def remove_small_components(image_gray, thred, connectivity=8):
    
    # Perform connected component analysis
    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(image_gray, connectivity=connectivity, ltype=cv2.CV_32S)
    mask = np.zeros_like(labels)

    # Loop over each component
    for i in range(num_labels):
        label_val = np.unique(image_gray[labels == i])
        assert label_val == 0 or label_val == 255
        # Filter out small components
        if stats[i][4] < thred:
            mask[labels == i] = 255 - label_val
        else:
            mask[labels == i] = label_val

    return mask.astype('uint8')


def mask_complete(img_path):

    # Load image
    img = cv2.imread(img_path)
    # Convert image to grayscale
    labels = img[:, :, 0]
    labels[labels != 255] = 0
    thred = calculate_thred(labels) * 2

    # Remove connected component with adaptive threshold 
    labels = remove_small_components(labels, thred, connectivity=8)
    labels = cv2.bitwise_not(labels)

    labels = remove_small_components(labels, thred, connectivity=4)
    labels = cv2.bitwise_not(labels)

    # Create output image
    output = np.repeat(labels[:, :, np.newaxis], 3, axis=2)

    return output


def mask_area_to_grayscale(img_path, data_folder):

    img = cv2.imread(img_path)
    mask_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    mask = cv2.imread(osp.join(data_folder, 'mask_clean.png'))

    mask_gray = cv2.bitwise_and(mask_gray, mask[:, :, 0])
    mask_gray = np.repeat(mask_gray[:, :, np.newaxis], 3, axis=2)
    
    return mask_gray


def elementary_method(data_folder):
    labels = cv2.imread(osp.join(data_folder, 'mask_clean.png'))[:, :, 0]
    # skeletonize
    labels[labels == 255] = 1
    labels = morphology.skeletonize(labels, method='lee').astype('uint8')
    labels[labels == 1] = 255 

    # Create output image
    output = np.repeat(labels[:, :, np.newaxis], 3, axis=2)
    # Display output image
    cv2.imwrite(osp.join(data_folder, 'elementary_result.png'), output)


def get_circle_pixels(y0, x0, h, w, r):
    x = np.arange(max(x0 - r, 1), min(x0 + r + 1, w -1))
    y = np.arange(max(y0 - r, 1), min(y0 + r + 1, h -1))
    yy, xx = np.meshgrid(y, x)
    circle = np.logical_and((xx - x0) ** 2 + (yy - y0) ** 2 >= (r-1) ** 2, (xx - x0) ** 2 + (yy - y0) ** 2 <= (r+1) ** 2)
    return np.column_stack([yy[circle], xx[circle]])


def sophisticated_method(data_folder, plan_png):

    # configure convolution kernel size
    ksize = 3
    image = cv2.imread(plan_png)
    mask_clean = cv2.imread(osp.join(data_folder, 'mask_clean.png'))[:, :, 0]

    img_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    img_blur = cv2.GaussianBlur(img_gray, (ksize, ksize), 1)
    # img_blur = cv2.blur(img_gray,(3,3))

    img_edge = cv2.Laplacian(img_blur,cv2.CV_8U,ksize=ksize)

    # Calculating the gradients
    gx = cv2.Sobel(np.float32(img_blur), cv2.CV_64F, 1, 0, 3)
    gy = cv2.Sobel(np.float32(img_blur), cv2.CV_64F, 0, 1, 3)

    # Conversion of Cartesian coordinates to polar 
    _, ang = cv2.cartToPolar(gx, gy, angleInDegrees = True)

    mag = img_edge.copy()

    # getting the dimensions of the input image  
    height, width = img_blur.shape

    # Looping through every pixel of the grayscale image
    for i_x in range(width):
        for i_y in range(height):

            grad_ang = ang[i_y, i_x]
            grad_ang = abs(grad_ang-180) if abs(grad_ang)>180 else abs(grad_ang)

            # selecting the neighbours of the target pixel
            # according to the gradient direction
            # In the x axis direction
            if grad_ang<= 22.5:
                neighb_1_x, neighb_1_y = i_x-1, i_y
                neighb_2_x, neighb_2_y = i_x + 1, i_y

            # top right (diagonal-1) direction
            elif grad_ang>22.5 and grad_ang<=(22.5 + 45):
                neighb_1_x, neighb_1_y = i_x-1, i_y-1
                neighb_2_x, neighb_2_y = i_x + 1, i_y + 1

            # In y-axis direction
            elif grad_ang>(22.5 + 45) and grad_ang<=(22.5 + 90):
                neighb_1_x, neighb_1_y = i_x, i_y-1
                neighb_2_x, neighb_2_y = i_x, i_y + 1

            # top left (diagonal-2) direction
            elif grad_ang>(22.5 + 90) and grad_ang<=(22.5 + 135):
                neighb_1_x, neighb_1_y = i_x-1, i_y + 1
                neighb_2_x, neighb_2_y = i_x + 1, i_y-1

            # Now it restarts the cycle
            elif grad_ang>(22.5 + 135) and grad_ang<=(22.5 + 180):
                neighb_1_x, neighb_1_y = i_x-1, i_y
                neighb_2_x, neighb_2_y = i_x + 1, i_y

            # Non-maximum suppression step
            if width>neighb_1_x>= 0 and height>neighb_1_y>= 0:
                if mag[i_y, i_x] <= mag[neighb_1_y, neighb_1_x]:
                    mag[i_y, i_x]= 0
                    continue

            if width>neighb_2_x>= 0 and height>neighb_2_y>= 0:
                if mag[i_y, i_x] <= mag[neighb_2_y, neighb_2_x]:
                    mag[i_y, i_x]= 0
                    

    mag = (mag / np.max(mag)) * 255
    mag = mag.astype('uint8')
    labels = cv2.bitwise_and(mag, mask_clean)

    # thredsholding with value greater than 20 as borderline pixels
    labels[labels > 20] = 255
    labels[labels <= 20] = 0

    # skeletonize
    labels[labels == 255] = 1
    labels = morphology.skeletonize(labels, method='lee').astype('uint8')
    labels[labels == 1] = 255 

    # end points detection
    mask_skel = labels.copy()
    mask_skel[mask_skel == 255] = 1

    kernel = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]], dtype=np.uint8)
    conv_res = cv2.filter2D(src=mask_skel, ddepth=-1, kernel=kernel)
    conv_res[conv_res != 1] = 0

    endpt = np.multiply(conv_res, mask_skel)
    endpt[endpt == 1] = 255 
    assert np.unique(endpt).all() in [0, 255]
    mask_skel[mask_skel == 1] = 255

    #  Graph-based connect algo
    gray = cv2.imread(osp.join(data_folder, "grayscale.png"))[:, :, 0]
    height, width = endpt.shape

    # init search radius
    r = 20
    improved_label = mask_skel.copy()
    endpt_coord_ls = [[y, x] for y, x in zip(*np.nonzero(endpt))]

    for src_y, src_x in tqdm(endpt_coord_ls):
        y1 = max(src_y - r, 0)
        y2 = min(src_y + r, height)
        x1 = max(src_x - r, 0)
        x2 = min(src_x + r, width)
        y0 = src_y - y1
        x0 = src_x - x1
        
        endpt_window = endpt[y1:y2, x1:x2]
        gray_window = gray[y1:y2, x1:x2]
        skel_window = mask_skel[y1:y2, x1:x2]
        mask_window = mask_clean[y1:y2, x1:x2]
        weights_window = np.zeros_like(skel_window)
        
        endpts_w_ls = np.array([[y+1, x+1] for y, x in zip(*np.nonzero(endpt_window[1:-1, 1:-1]))])
        if len(endpts_w_ls) == 0:
            continue
        # distance_ls = [np.linalg.norm([y -y0, x -x0]) for y, x in endpts_w_ls]
        distances = np.sqrt(np.sum((endpts_w_ls - np.array([y0, x0]))**2, axis=1))
        # take 5 closest endpoint to connect
        indices = np.argsort(distances)[1:5]
        dst_pts_ls = endpts_w_ls[indices]
        
        G = nx.DiGraph()
        h, w = endpt_window.shape
        for y in range(h):
            for x in range(w):
                if skel_window[y, x] == 255:
                    weight = 1
                elif mask_window[y, x] == 0:
                    weight = 10000
                else:
                    weight = gray_window[y, x]

                G.add_node((y,x))
                weights_window[y, x] = weight

                if 0 < x < w - 1 and 0 < y < h - 1:
                    G.add_edge((y,x-1), (y,x), weight=weight)
                    G.add_edge((y-1,x-1), (y,x), weight=weight)
                    G.add_edge((y+1,x-1), (y,x), weight=weight)
                    G.add_edge((y-1,x), (y,x), weight=weight)
                    G.add_edge((y+1,x), (y,x), weight=weight)
                    G.add_edge((y-1,x+1), (y,x), weight=weight)
                    G.add_edge((y,x+1), (y,x), weight=weight)
                    G.add_edge((y+1,x+1), (y,x), weight=weight)
        
        for dst_y, dst_x in dst_pts_ls:
            path = nx.shortest_path(G, source=(y0,x0), target=(dst_y, dst_x), weight='weight')
            path_w_y, path_w_x = zip(*path)
            
            weights_path = weights_window[path_w_y, path_w_x][1:-1]
            
            if len(weights_path) == 0 or max(weights_path) > 210 or np.mean(weights_path) <= 1:
                continue
            path_y = np.array(path_w_y) + y1 
            path_x = np.array(path_w_x) + x1
            
            improved_label[path_y, path_x] = 255

    improved_label = improved_label.astype('uint8')
    improved_label[improved_label != 255] = 0

    # clean the improved labels 
    # remove small components
    thred = calculate_thred(improved_label)
    improved_label = remove_small_components(improved_label, thred, connectivity=8)
    improved_label = cv2.bitwise_not(improved_label)

    improved_label = remove_small_components(improved_label, thred, connectivity=4)
    improved_label = cv2.bitwise_not(improved_label)

    # skeletonize
    improved_label[improved_label == 255] = 1
    improved_label = morphology.skeletonize(improved_label, method='lee').astype('uint8')

    # calculate updated end points
    kernel = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]], dtype=np.uint8)
    conv_res = cv2.filter2D(src=improved_label, ddepth=-1, kernel=kernel)
    conv_res[conv_res != 1] = 0

    endpt = np.multiply(conv_res, improved_label)
    endpt[endpt == 1] = 255 
    assert np.unique(endpt).all() in [0, 255]


    # search around potential candidate points to solve T junction and ground truth defects
    buffer_dst = 3
    improved_label[improved_label == 1] = 255 
    skel = improved_label
    final_label = improved_label.copy()
    endpt_coord_ls = [[y, x] for y, x in zip(*np.nonzero(endpt))]

    for src_y, src_x in tqdm(endpt_coord_ls):
        flag = 1
        r = 0
        while flag:
            if r >= 20:
                break
            r += 5  
            y1 = max(src_y - r - buffer_dst, 0)
            y2 = min(src_y + r + buffer_dst, height)
            x1 = max(src_x - r - buffer_dst, 0)
            x2 = min(src_x + r + buffer_dst, width)
            y0 = src_y - y1
            x0 = src_x - x1

            endpt_window = endpt[y1:y2, x1:x2]
            gray_window = gray[y1:y2, x1:x2]
            skel_window = skel[y1:y2, x1:x2]
            mask_window = mask_clean[y1:y2, x1:x2]
            weights_window = np.zeros_like(skel_window)

            circle_pixels_ls = get_circle_pixels(y0, x0, height, width, r)
            circle_pixels_ls = np.array([[y,x] for y,x in circle_pixels_ls if y < skel_window.shape[0] and x < skel_window.shape[1]])
            candidate_px_idx = skel_window[circle_pixels_ls[:, 0], circle_pixels_ls[:, 1]] == 255
            dst_pts_ls = circle_pixels_ls[candidate_px_idx]

            if len(dst_pts_ls) == 0:
                continue

            G = nx.DiGraph()
            h, w = endpt_window.shape
            for y in range(h):
                for x in range(w):
                    if skel_window[y, x] == 255:
                        # weight = gray_window[y, x]
                        weight = 1
                    elif mask_window[y, x] == 0:
                        weight = 10000
                    else:
                        weight = gray_window[y, x]

                    G.add_node((y,x))
                    weights_window[y, x] = weight

                    if 0 < x < w - 1 and 0 < y < h - 1:
                        G.add_edge((y,x-1), (y,x), weight=weight)
                        G.add_edge((y-1,x-1), (y,x), weight=weight)
                        G.add_edge((y+1,x-1), (y,x), weight=weight)
                        G.add_edge((y-1,x), (y,x), weight=weight)
                        G.add_edge((y+1,x), (y,x), weight=weight)
                        G.add_edge((y-1,x+1), (y,x), weight=weight)
                        G.add_edge((y,x+1), (y,x), weight=weight)
                        G.add_edge((y+1,x+1), (y,x), weight=weight)

            for dst_y, dst_x in dst_pts_ls:
                path = nx.shortest_path(G, source=(y0,x0), target=(dst_y, dst_x), weight='weight')
                path_w_y, path_w_x = zip(*path)

                weights_path = weights_window[path_w_y, path_w_x][1:-1]
                
                tol = 8
                path_len = len(weights_path) 
                if path_len == 0 or np.mean(weights_path) == 1 or max(weights_path) > 210:
                    continue
                # if path_len > tol and sorted(weights_path, reverse=True)[tol-1] > 210:
                #     continue
                path_y = np.array(path_w_y) + y1 
                path_x = np.array(path_w_x) + x1

                final_label[path_y, path_x] = 255
                flag = 0
    
    # skeleton 
    final_label[final_label == 255] = 1
    final_label = morphology.skeletonize(final_label, method='lee').astype('uint8')
    final_label[final_label == 1] = 255 

    final_label = np.repeat(final_label[:, :, np.newaxis], 3, axis=2)
    cv2.imwrite(osp.join(data_folder, 'sophisticated_result.png'), final_label)


def main():

    # init argparse 
    args = parse_args()
    tif_folder = args.tif_path
    mask_folder = args.line_mask
    deline_folder = args.save_path


    origin_plan_ls = os.listdir(tif_folder)

    origin_plan_ls = [file for file in origin_plan_ls if file.endswith('.tif') and not file.endswith('Assemblage.tif')]

    for origin_plan in origin_plan_ls:
        plan_name = origin_plan.split('.')[0]
        commune = plan_name.split('_')[2]
        commune_temp = osp.join(deline_folder, commune + '-temp')
        plan_temp_folder = osp.join(commune_temp, plan_name)

        print('Current processing plan: {}'.format(plan_name))
        if not osp.exists(commune_temp):
            os.makedirs(commune_temp)
            
        if not osp.exists(plan_temp_folder):
            os.makedirs(plan_temp_folder)

        mask_path = osp.join(mask_folder, commune, plan_name + '.png')
        plan_png = osp.join(plan_temp_folder, plan_name + '.png')
        plan_tif = osp.join(tif_folder, origin_plan)

        if not os.path.exists(plan_png):
            tif = cv2.imread(plan_tif)
            cv2.imwrite(plan_temp_folder + '/{}.png'.format(plan_name), tif)

        # clean and remove small components (false positive or false negative) in prediction
        # Save cleaned mask to temp folder
        print('Segmentation mask cleaning in process...')
        mask_clean = mask_complete(mask_path)
        cv2.imwrite(osp.join(plan_temp_folder, 'mask_clean.png'), mask_clean)

        # create the grayscale image of the original cadastral map
        gray_mask_area = mask_area_to_grayscale(plan_png, plan_temp_folder)
        cv2.imwrite(osp.join(plan_temp_folder, 'grayscale.png'), gray_mask_area)

        # ELEMENTARY method 
        # skeletonize the cleaned mask as the topology
        print('Implement elementary method...')
        elementary_method(plan_temp_folder)

        # SOPHISTICATED method 
        print('Implement sophisticated method...')
        sophisticated_method(plan_temp_folder, plan_png)
    
    print('Delineation finish!')



if __name__ == '__main__':
    main()